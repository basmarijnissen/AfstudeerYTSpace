{"version":3,"file":"background.bundle.js","sources":["webpack://ytspace/./node_modules/uuid/dist/esm-browser/regex.js","webpack://ytspace/./node_modules/uuid/dist/esm-browser/rng.js","webpack://ytspace/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://ytspace/./node_modules/uuid/dist/esm-browser/v4.js","webpack://ytspace/./node_modules/uuid/dist/esm-browser/validate.js","webpack://ytspace/webpack/bootstrap","webpack://ytspace/webpack/runtime/define property getters","webpack://ytspace/webpack/runtime/hasOwnProperty shorthand","webpack://ytspace/webpack/runtime/make namespace object","webpack://ytspace/./src/js/background.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { v4 as uuidv4 } from \"uuid\";\nvar YouTubeWatch = \"https://www.youtube.com/watch?v=\";\nvar YouTubeHome = \"https://www.youtube.com/\";\nvar dataID, kijktijd, start, end, videodata;\nvar kijktVideo,\n  dataPushed = new Boolean(false);\nvar counter = 0;\nvar kijkdata = [];\n\nconsole.log(\"ViewSpace initialized.\");\n//herlaad als de actieve pagina verandert\nchrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {\n  if (changeInfo.status == \"complete\") {\n    start, (end = 0);\n\n    // als de persoon een video gaat kijken:\n    if (tab.url.indexOf(YouTubeWatch) !== -1) {\n      window.setTimeout(LoadPause, 100);\n      function LoadPause() {\n        chrome.tabs.executeScript(null, { file: \"pauzeren.bundle.js\" });\n      }\n\n      // als YouTube video geladen is, start script\n      window.setTimeout(LoadScript, 3000);\n      function LoadScript() {\n        if (counter == 0) {\n          chrome.tabs.executeScript(\n            null,\n            { file: \"foreground.bundle.js\" },\n            () => console.log(\"Foreground.js loaded\")\n          );\n          counter += 1;\n        } else if (counter == 1) {\n          console.log(\"Already initialized\");\n        }\n      }\n      // Begin cyclus\n      if ((kijktVideo = false)) {\n        LogStart();\n        // als er al een video openstond, sluit cyclus en begin opnieuw\n      } else if ((kijktVideo = true)) {\n        LogEnd();\n        LogStart();\n      }\n      // als de geopende pagina geen YouTube video is\n    } else if (tab.url === YouTubeHome) {\n      if (kijktVideo === true) {\n        //sluit de video af\n        LogEnd();\n        kijktVideo = false;\n      } else if (kijktVideo === false) {\n        console.log(\"No previous and current video detected.\");\n      }\n    }\n  } else if (changeInfo.status == \"loading\") {\n  }\n});\n\nfunction LogStart() {\n  //zeg dat de persoon een video kijkt\n  kijktVideo = true;\n  videodata = [];\n\n  //geef video een unieke id\n  dataID = uuidv4();\n  videodata.push(dataID);\n  console.log(\"Starting log of \" + dataID);\n\n  //sla url op\n  chrome.tabs.query({ currentWindow: true, active: true }, function (tabs) {\n    videodata.push(tabs[0].url);\n    console.log(\"video url saved: \" + tabs[0].url);\n\n    //sla tijd van openen op\n    start = new Date();\n    console.log(\"Start time saved: \" + start);\n  });\n}\n\nfunction LogEnd() {\n  kijktVideo = false;\n  if (videodata) {\n    //de persoon stopt met het kijken van de video\n    console.log(\"Ending log of \" + dataID);\n\n    // bereken de tijd dat de persoon de video kijkt\n    end = new Date();\n    kijktijd = end - start;\n    kijktijd = kijktijd / 1000;\n    videodata.push(kijktijd);\n\n    //geef door dat alle data verzameld is\n    dataPushed = true;\n    if (dataPushed === true) {\n      //stuur data door naar sessie array\n      kijkdata.push(videodata);\n      console.log(\"pushing log to kijkdata.\");\n      console.log(kijkdata);\n      videodata = [];\n    }\n  } else {\n    console.log(\"No log to push to kijkdata.\");\n  }\n}\n\nchrome.windows.onRemoved.addListener(function (windowId) {\n  chrome.storage.sync.set({ kijkdata: value }, function () {\n    console.log(\"Value is set to \" + value);\n  });\n  alert(\"!! Je planeet wordt bijgewerkt... !!\");\n});\n"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;A;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}